>> Ch04 Working with Key/Value Pairs <<


// 4-8 reduceByKey, mapValues
// key 별로 value 들의 avarage 를 구하기
val data = List(("panda", 0), ("pink", 3), ("pirate", 3), ("panda", 1), ("pink", 4))
val pair = sc.parallelize(data.map(x => (x, 1)))
// var pair = sc.parallelize(data.map{ case (x, y) => (x, y, 1) }
val pair_map = pair.mapValues(x => (x, 1))
val pair_reduce = pair_map.reduceByKey((x, y) => (x._1 + y._1, x._2 + y._2))
val pair_avr = pair_reduce.mapValues(x => (x._1, x._2, "avr = " + x._1.toFloat / x._2))


// 4-10 reduceByKey
// word counting
val alice = sc.textFile("alice.txt")
val words = alice.flatMap(x => x.split(" "))
val countMap = words.countByValue()
val result = words.map(x => (x, 1)).reduceByKey((x, y) => x + y)

// why doesn't sort function work properly?
// result.collect().sortBy(_._1).foreach(println)


// 4-13 combineByKey
// key 가 value 를 가지고 있을 때, key 별 value 의 평균을 구함 (word counting 에는 적합하지 않음)
val data = List(("panda", 0), ("pink", 3), ("pirate", 3), ("panda", 1), ("pink", 4))
val pair = sc.parallelize(data)
val avrResult = pair.combineByKey(
  v => (v, 1),                                      // value 가 (value, 1) 로 매핑됨.
  (acc: (Int, Int), v) => (acc._1 + v, acc._2 + 1), // 특정 key 에 대한 (value, Int) 와 미처리 value 를 묶어서 처리.
  (acc1: (Int, Int), acc2: (Int, Int)) => (acc1._1 + acc2._1, acc1._2 + acc2._2) ).map {
    case (key, value) => (key, value._1 / value._2.toFloat) }
                                                    // partition 간 동일 (value, Int) 2개를 묶어서 처리.
val resultMap = avrResult.collectAsMap()
resultMap.map(println)    // collect() 하고 Map 화한 다음, println(_) 을 돌려줌.


// 4-17 join
// 안되네?
class Store(name: String) extends Serializable

val storeAddress = sc.parallelize(Seq(
  (new Store("Ritual"), "1026 Valencia St"), (new Store("Philz"), "748 Van Ness Ave"),
  (new Store("Philz"), "3101 24th St"), (new Store("Starbucks"), "Seattle")) )

val storeRating = sc.parallelize(Seq(
  (new Store("Ritual"), 4.9), (new Store("Philz"), 4.8) ))

val join = storeAddress.join(storeRating)
join.map(println)


// 4-25 Page Rank
//
// key: pageId, value: Seq[String] 이웃 pageId Seq
// links = (("1", ("0", "2")), ("3", ("0", "4")), ("5", ("0", "6")))
val links = sc.objectFile[(String, Seq[String])]("links")
              .partitionBy(new HashPartitioner(100))
              .persist()

// key: pageId, value: rank
// ranks = (("1", 1.0), ("3", 1.0), ("5", 1.0))
var ranks = links.mapValues(v => 1.0)

// 10번 반복
// key: pageId, value: (이웃 pageId Seq), rank
for (i <- 0 until 10) {
  // links.join(ranks) 의 결과로 (pageId, (이웃 pageId, rank)) 형태의 카테시안 곱이 됨.
  // (key 가 정확히 일치하므로 value 의 개수는 그대로이다.)
  // (5,((0,6),1.0))(3,((0,4),1.0))(1,((0,2),1.0))

  // 그리고 map 의 결과로 이웃 pageId 들은 (pageId, rank / 이웃 pageId count) 형태가 된다.
  // 마지막으로 flatMap 의 결과로 contributions 는
  // (0,0.5)(0,0.5)(4,0.5)(6,0.5)(0,0.5)(2,0.5)
  val contributions = links.join(ranks).flatMap {
    case (pageId, (links, rank)) =>
      links.map(dest => (dest, rank / links.size))
  }

  // contributions 를 reduceByKey 해서 값들을 합하고, 그 값들에 0.15 + 0.85 * v 연산을 한다.
  // (4,0.575)(0,1.4249999999999998)(6,0.575)(2,0.575)
  ranks = contributions.reduceByKey((x, y) => x + y).mapValues(v => 0.15 + 0.85 * v)
}

ranks.saveAsTextFile("ranks")



val linksData = List(("1", List("0", "2")), ("3", List("0", "4")), ("5", List("0", "6")))
val links = sc.parallelize(linksData)
var ranks = links.mapValues(v => 1.0)

// 루프시작
var cont = links.join(ranks)

// 이거를 하면 1, 3, 5 가 없어지는데??
val contributions = cont.flatMap {
  case (pageId, (links, rank)) => links.map(dest => (dest, rank / links.size))
}
// 루프종료
